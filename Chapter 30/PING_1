import numpy as np
import matplotlib.pyplot as plt
import time

# -----------------------------
# HH rate functions (E/I Cells)
# -----------------------------
def a_m_e(v): return (0.32*(v+54))/(1-np.exp(-(v+54)/4))
def b_m_e(v): return (0.28*(v+27))/(np.exp((v+27)/5)-1)
def a_n_e(v): return (0.032*(v+52))/(1-np.exp(-(v+52)/5))
def b_n_e(v): return 0.5*np.exp(-(v+57)/40)
def a_h_e(v): return 0.128*np.exp(-(v+50)/18)
def b_h_e(v): return 4/(1+np.exp(-(v+27)/5))
def m_e_inf(v): return a_m_e(v)/(a_m_e(v)+b_m_e(v))
def n_e_inf(v): return a_n_e(v)/(a_n_e(v)+b_n_e(v))
def h_e_inf(v): return a_h_e(v)/(a_h_e(v)+b_h_e(v))
def tau_n_e(v): return 1/(a_n_e(v)+b_n_e(v))
def tau_h_e(v): return 1/(a_h_e(v)+b_h_e(v))

def a_m_i(v): return (0.1*(v+35))/(1-np.exp(-(v+35)/10))
def b_m_i(v): return 4*np.exp(-(v+60)/18)
def a_n_i(v): return (-0.01*(v+34))/(np.exp(-0.1*(v+34))-1)
def b_n_i(v): return 0.125*np.exp(-(v+44)/80)
def a_h_i(v): return 0.07*np.exp(-(v+58)/20)
def b_h_i(v): return 1/(np.exp(-0.1*(v+28))+1)
def m_i_inf(v): return a_m_i(v)/(a_m_i(v)+b_m_i(v))
def n_i_inf(v): return a_n_i(v)/(a_n_i(v)+b_n_i(v))
def h_i_inf(v): return a_h_i(v)/(a_h_i(v)+b_h_i(v))
def tau_n_i(v): return 1/(a_n_i(v)+b_n_i(v))/5.0
def tau_h_i(v): return 1/(a_h_i(v)+b_h_i(v))/5.0

# -----------------------------
# tau_d_q function
# -----------------------------
def tau_d_q_function(tau_d, tau_r, tau_hat):
    left, right = 1.0, tau_r
    while tau_peak_function(tau_d, tau_r, left) > tau_hat: left/=2
    while tau_peak_function(tau_d, tau_r, right) < tau_hat: right*=2
    tol = 1e-12
    while right - left > tol:
        mid = (left+right)/2
        if tau_peak_function(tau_d,tau_r,mid)<=tau_hat:
            left = mid
        else:
            right = mid
    return (left+right)/2

def tau_peak_function(tau_d, tau_r, tau_d_q):
    dt = 0.01
    s = 0.0
    t = 0.0
    s_inc = np.exp(-t/tau_d_q)*(1-s)/tau_r - s/tau_d
    while s_inc>0:
        t_old = t
        s_inc_old = s_inc
        s_tmp = s + dt/2*s_inc
        s_inc_tmp = np.exp(-(t+dt/2)/tau_d_q)*(1-s_tmp)/tau_r - s_tmp/tau_d
        s += dt*s_inc_tmp
        t += dt
        s_inc = np.exp(-t/tau_d_q)*(1-s)/tau_r - s/tau_d
    return (t_old*(-s_inc)+t*s_inc_old)/(s_inc_old-s_inc)

# -----------------------------
# rtm_init function
# -----------------------------
def rtm_init_python(i_ext, phi_vec):
    num = len(phi_vec)
    max_spikes = 3
    rtm_init = np.zeros((num,3))
    dt = 0.01; dt05 = dt/2
    v = -70*np.ones(num)
    m = m_e_inf(v)
    h = h_e_inf(v)
    n = n_e_inf(v)
    t = 0
    num_spikes = np.zeros(num,dtype=int)
    done = np.zeros(num,bool)
    t_spikes = np.zeros((num,max_spikes))

    c,g_k,g_na,g_l = 1.0, 80.0, 100.0, 0.1
    v_k,v_na,v_l = -100.0, 50.0, -67.0

    while np.sum(done)<num and t<2000:
        v_old, h_old, n_old, t_old = v.copy(), h.copy(), n.copy(), t
        v_inc = (g_k*n**4*(v_k-v) + g_na*m**3*h*(v_na-v) + g_l*(v_l-v)+i_ext)/c
        h_inc = (h_e_inf(v)-h)/tau_h_e(v)
        n_inc = (n_e_inf(v)-n)/tau_n_e(v)

        v_tmp = v + dt05*v_inc
        m_tmp = m_e_inf(v_tmp)
        h_tmp = h + dt05*h_inc
        n_tmp = n + dt05*n_inc

        v_inc = (g_k*n_tmp**4*(v_k-v_tmp) + g_na*m_tmp**3*h_tmp*(v_na-v_tmp) + g_l*(v_l-v_tmp)+i_ext)/c
        h_inc = (h_e_inf(v_tmp)-h_tmp)/tau_h_e(v_tmp)
        n_inc = (n_e_inf(v_tmp)-n_tmp)/tau_n_e(v_tmp)

        v += dt*v_inc
        m = m_e_inf(v)
        h += dt*h_inc
        n += dt*n_inc
        t += dt

        ind = np.where((v_old>=-20)&(v<-20))[0]
        for k in ind:
            if num_spikes[k]<max_spikes:
                t_spikes[k,num_spikes[k]] = (t_old*(-20 - v[k]) + t*(v_old[k]-(-20))) / (v_old[k]-v[k])
                num_spikes[k] += 1

        thr = t_spikes[:,max_spikes-1] + phi_vec*(t_spikes[:,max_spikes-1]-t_spikes[:,max_spikes-2])
        ind_done = np.where((num_spikes==max_spikes) & (t>thr) & (t_old<=thr))[0]
        for k in ind_done:
            rtm_init[k,0] = (v_old[k]*(t-thr[k]) + v[k]*(thr[k]-t_old))/dt
            rtm_init[k,1] = (h_old[k]*(t-thr[k]) + h[k]*(thr[k]-t_old))/dt
            rtm_init[k,2] = (n_old[k]*(t-thr[k]) + n[k]*(thr[k]-t_old))/dt
        done[ind_done] = True

    ind = np.where(~done)[0]
    rtm_init[ind,0] = v[ind]; rtm_init[ind,1]=h[ind]; rtm_init[ind,2]=n[ind]
    return rtm_init

# -----------------------------
# -----------------------------
# Simulation parameters
np.random.seed(63806)
num_e,num_i = 200, 50
sigma_e = 0.05; sigma_i=0.0
i_ext_e = 1.4*(1+sigma_e*np.random.randn(num_e))
i_ext_i = 0.0*(1+sigma_i*np.random.randn(num_i))

g_hat_ee, g_hat_ei, g_hat_ie, g_hat_ii = 0, 0.25, 0.25, 0.25
p_ee, p_ei, p_ie, p_ii = 0.5, 0.5, 0.5, 0.5

v_rev_e, v_rev_i = 0, -75
tau_r_e, tau_peak_e, tau_d_e = 0.5, 0.5, 3
tau_r_i, tau_peak_i, tau_d_i = 0.5, 0.5, 9

t_final = 200
dt = 0.01
dt05 = dt/2
m_steps = int(t_final/dt)

# Synaptic connectivity
u_ee = np.random.rand(num_e,num_e)
u_ei = np.random.rand(num_e,num_i)
u_ie = np.random.rand(num_i,num_e)
u_ii = np.random.rand(num_i,num_i)

g_ee = g_hat_ee*(u_ee<p_ee)/(num_e*p_ee)
g_ei = g_hat_ei*(u_ei<p_ei)/(num_e*p_ei)
g_ie = g_hat_ie*(u_ie<p_ie)/(num_i*p_ie)
g_ii = g_hat_ii*(u_ii<p_ii)/(num_i*p_ii)

tau_dq_e = tau_d_q_function(tau_d_e,tau_r_e,tau_peak_e)
tau_dq_i = tau_d_q_function(tau_d_i,tau_r_i,tau_peak_i)

# Initialize neurons
iv = rtm_init_python(i_ext_e, np.random.rand(num_e))
v_e,m_e,h_e,n_e = iv[:,0], m_e_inf(iv[:,0]), iv[:,1], iv[:,2]
q_e,s_e = np.zeros(num_e),np.zeros(num_e)

v_i = -75*np.ones(num_i)
m_i,h_i,n_i = m_i_inf(v_i), h_i_inf(v_i), n_i_inf(v_i)
q_i,s_i = np.zeros(num_i),np.zeros(num_i)

# Spike recording
num_spikes_e,num_spikes_i = 0,0
t_e_spikes,t_i_spikes = [],[]
i_e_spikes,i_i_spikes = [],[]

lfp = np.zeros(m_steps+1)
lfp[0] = np.mean(v_e)

# -----------------------------
# Simulation loop
# -----------------------------
start_time = time.time()

for k in range(1,m_steps+1):
    t_old = (k-1)*dt
    t_new = k*dt

    E_Na_e = 50
    E_K_e = -100
    E_L_e = -67
    g_Na_e = 100
    g_K_e = 80
    g_L_e = 0.1
    c_e = 1

    E_Na_i = 55
    E_K_i = -90
    E_L_i = -65
    g_Na_i = 35
    g_K_i = 9
    g_L_i = 0.1
    c_i = 1

    # Compute increments (E and I cells)
    v_e_inc = (g_L_e*(E_L_e-v_e) + g_K_e*n_e**4*(E_K_e-v_e) + g_Na_e*m_e**3*h_e*(E_Na_e-v_e) \
        + g_ee.T@s_e*(v_rev_e-v_e) + g_ie.T@s_i*(v_rev_i-v_e) + i_ext_e) / c_e
    n_e_inc = (n_e_inf(v_e)-n_e)/tau_n_e(v_e)
    h_e_inc = (h_e_inf(v_e)-h_e)/tau_h_e(v_e)
    q_e_inc = ((1+np.tanh(v_e/10))/2*(1-q_e)/0.1 - q_e/tau_dq_e)
    s_e_inc = q_e*(1-s_e)/tau_r_e - s_e/tau_d_e

    v_i_inc = (g_L_i*(E_L_i-v_i) + g_K_i*n_i**4*(E_K_i-v_i) + g_Na_i*m_i**3*h_i*(E_Na_i-v_i) \
        + g_ei.T@s_e*(v_rev_e-v_i) + g_ii.T@s_i*(v_rev_i-v_i) + i_ext_i) / c_i
    n_i_inc = (n_i_inf(v_i)-n_i)/tau_n_i(v_i)
    h_i_inc = (h_i_inf(v_i)-h_i)/tau_h_i(v_i)
    q_i_inc = ((1+np.tanh(v_i/10))/2*(1-q_i)/0.1 - q_i/tau_dq_i)
    s_i_inc = q_i*(1-s_i)/tau_r_i - s_i/tau_d_i

    # Midpoint update
    v_e_tmp = v_e + dt05*v_e_inc
    n_e_tmp = n_e + dt05*n_e_inc
    m_e_tmp = m_e_inf(v_e_tmp)
    h_e_tmp = h_e + dt05*h_e_inc
    q_e_tmp = q_e + dt05*q_e_inc
    s_e_tmp = s_e + dt05*s_e_inc

    v_i_tmp = v_i + dt05*v_i_inc
    n_i_tmp = n_i + dt05*n_i_inc
    m_i_tmp = m_i_inf(v_i_tmp)
    h_i_tmp = h_i + dt05*h_i_inc
    q_i_tmp = q_i + dt05*q_i_inc
    s_i_tmp = s_i + dt05*s_i_inc

    # Recompute increments at midpoint
    v_e_inc = (g_L_e*(E_L_e-v_e_tmp) + g_K_e*n_e_tmp**4*(E_K_e-v_e_tmp) + g_Na_e*m_e_tmp**3*h_e_tmp*(E_Na_e-v_e_tmp) \
        + g_ee.T@s_e_tmp*(v_rev_e-v_e_tmp) + g_ie.T@s_i_tmp*(v_rev_i-v_e_tmp) + i_ext_e) / c_e
    n_e_inc = (n_e_inf(v_e_tmp)-n_e_tmp)/tau_n_e(v_e_tmp)
    h_e_inc = (h_e_inf(v_e_tmp)-h_e_tmp)/tau_h_e(v_e_tmp)
    q_e_inc = ((1+np.tanh(v_e_tmp/10))/2*(1-q_e_tmp)/0.1 - q_e_tmp/tau_dq_e)
    s_e_inc = q_e_tmp*(1-s_e_tmp)/tau_r_e - s_e_tmp/tau_d_e

    v_i_inc = (g_L_i*(E_L_i-v_i_tmp) + g_K_i*n_i_tmp**4*(E_K_i-v_i_tmp) + g_Na_i*m_i_tmp**3*h_i_tmp*(E_Na_i-v_i_tmp) \
        + g_ei.T@s_e_tmp*(v_rev_e-v_i_tmp) + g_ii.T@s_i_tmp*(v_rev_i-v_i_tmp) + i_ext_i) / c_i
    n_i_inc = (n_i_inf(v_i_tmp)-n_i_tmp)/tau_n_i(v_i_tmp)
    h_i_inc = (h_i_inf(v_i_tmp)-h_i_tmp)/tau_h_i(v_i_tmp)
    q_i_inc = ((1+np.tanh(v_i_tmp/10))/2*(1-q_i_tmp)/0.1 - q_i_tmp/tau_dq_i)
    s_i_inc = q_i_tmp*(1-s_i_tmp)/tau_r_i - s_i_tmp/tau_d_i

    # Update state variables
    v_e_old, v_i_old = v_e.copy(), v_i.copy()
    v_e += dt*v_e_inc; m_e = m_e_inf(v_e); h_e += dt*h_e_inc; n_e += dt*n_e_inc; q_e += dt*q_e_inc; s_e += dt*s_e_inc
    v_i += dt*v_i_inc; m_i = m_i_inf(v_i); h_i += dt*h_i_inc; n_i += dt*n_i_inc; q_i += dt*q_i_inc; s_i += dt*s_i_inc

    # Spike detection
    which_e = np.where((v_e_old>-20) & (v_e<=-20))[0]
    which_i = np.where((v_i_old>-20) & (v_i<=-20))[0]
    if len(which_e)>0:
        i_e_spikes.extend(which_e)
        t_e_spikes.extend(((-20-v_e[which_e])*(k-1)*dt + (v_e_old[which_e]+20)*k*dt)/(-v_e[which_e]+v_e_old[which_e]))
        num_spikes_e += len(which_e)
    if len(which_i)>0:
        i_i_spikes.extend(which_i)
        t_i_spikes.extend(((-20-v_i[which_i])*(k-1)*dt + (v_i_old[which_i]+20)*k*dt)/(-v_i[which_i]+v_i_old[which_i]))
        num_spikes_i += len(which_i)

    lfp[k] = np.mean(v_e)

print("Simulation finished in %.2f sec"% (time.time()-start_time))

# -----------------------------
# Raster + LFP plotting
t_e_spikes = np.array(t_e_spikes)
i_e_spikes = np.array(i_e_spikes)
t_i_spikes = np.array(t_i_spikes)
i_i_spikes = np.array(i_i_spikes)

plt.figure(figsize=(12,8))

# ---------- Rastergram ----------
plt.subplot(2,1,1)
if len(t_i_spikes)>0:
    plt.plot(t_i_spikes, i_i_spikes, '.b', label='I-cells')
if len(t_e_spikes)>0:
    plt.plot(t_e_spikes, i_e_spikes + num_i, '.r', label='E-cells')

# ---------- Separator line between E and I ----------
plt.plot([0, t_final], [num_i + 0.5, num_i + 0.5], '--k', linewidth=1)
plt.yticks([num_i, num_e+num_i], ['I-cells','E-cells'])
plt.xlim(0, t_final)
plt.ylim(0, num_e+num_i+1)
plt.xlabel('Time [ms]')
plt.ylabel('Neuron index')
plt.title('Rastergram')
plt.legend()

# ---------- LFP ----------
plt.subplot(2,1,2)
plt.plot(np.arange(0, m_steps+1)*dt, lfp, '-k', linewidth=2)
plt.xlabel('Time [ms]')
plt.ylabel('Mean membrane potential (E-cells)')
plt.xlim(0, t_final)
plt.ylim(-100, 50)

plt.tight_layout()
plt.show()
